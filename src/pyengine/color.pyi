from abc import ABC
from dataclasses import dataclass
from enum import Enum
from typing import Callable
from typing import ClassVar
from typing import Final
from typing import Sequence
from typing import Union
from typing import overload

import numpy as np
from PyxelEngine2.vector import Vector3
from PyxelEngine2.vector import Vector3c
from PyxelEngine2.vector import Vector4c

DType = Union[int, np.uint8]

IBlendEqn = Callable[[int, int], int]
IBlendFunc = Callable[[int, int, int, int], int]

class BlendEqn(int, Enum):
    ADD: BlendEqn = ...

    SUBTRACT: BlendEqn = ...
    REVERSE_SUBTRACT: BlendEqn = ...

    MIN: BlendEqn = ...
    MAX: BlendEqn = ...

    def __new__(cls, gl_ref: int, func: IBlendEqn) -> BlendEqn: ...
    def __init__(self, gl_ref: int, func: IBlendEqn):
        self._func: IBlendEqn = ...
    def __call__(self, src: int, dst: int) -> int: ...

class BlendFunc(int, Enum):
    ZERO: BlendFunc = ...
    ONE: BlendFunc = ...

    SRC_COLOR: BlendFunc = ...
    ONE_MINUS_SRC_COLOR: BlendFunc = ...
    SRC_ALPHA: BlendFunc = ...
    ONE_MINUS_SRC_ALPHA: BlendFunc = ...

    DST_COLOR: BlendFunc = ...
    ONE_MINUS_DST_COLOR: BlendFunc = ...
    DST_ALPHA: BlendFunc = ...
    ONE_MINUS_DST_ALPHA: BlendFunc = ...

    def __new__(cls, gl_ref: int, func: IBlendFunc) -> BlendEqn: ...
    def __init__(self, gl_ref: int, func: IBlendFunc):
        self._func: IBlendFunc = ...
    def __call__(self, c_src: int, a_src: int, c_dst: int, a_dst: int) -> int: ...

@dataclass(frozen=True)
class BlendMode:
    NONE: ClassVar[BlendMode] = ...
    ALPHA: ClassVar[BlendMode] = ...
    ADDITIVE: ClassVar[BlendMode] = ...
    MULTIPLICATIVE: ClassVar[BlendMode] = ...
    STENCIL: ClassVar[BlendMode] = ...
    ADD_COLORS: ClassVar[BlendMode] = ...
    SUB_COLORS: ClassVar[BlendMode] = ...
    ILLUMINATE: ClassVar[BlendMode] = ...

    DEFAULT: ClassVar[BlendMode] = ...

    blend_eqn: BlendEqn
    src_func: BlendFunc
    dst_func: BlendFunc

    def __init__(self, blend_eqn: BlendEqn, src_func: BlendFunc, dst_func: BlendFunc): ...

class Colorc(ABC):
    def __eq__(self, other: ColorLike) -> bool: ...
    def __ne__(self, other: ColorLike) -> bool: ...
    def __add__(self, other: ColorLike) -> Color: ...
    def __sub__(self, other: ColorLike) -> Color: ...
    def __mul__(self, other: ColorLike) -> Color: ...
    def __div__(self, other: ColorLike) -> Color: ...
    def __truediv__(self, other: ColorLike) -> Color: ...
    def __floordiv__(self, other: ColorLike) -> Color: ...
    def __mod__(self, other: ColorLike) -> Color: ...
    def __divmod__(self, other: ColorLike) -> Color: ...
    def __pow__(self, other: ColorLike) -> Color: ...
    def __matmul__(self, other: ColorLike) -> Color: ...
    def __neg__(self, other: ColorLike) -> Color: ...
    def __pos__(self, other: ColorLike) -> Color: ...
    def __abs__(self, other: ColorLike) -> Color: ...
    @property
    def r(self) -> int: ...
    @property
    def g(self) -> int: ...
    @property
    def b(self) -> int: ...
    @property
    def a(self) -> int: ...
    @property
    def rf(self) -> float: ...
    @property
    def gf(self) -> float: ...
    @property
    def bf(self) -> float: ...
    @property
    def af(self) -> float: ...
    @property
    def hsv(self) -> Vector3: ...
    def to_int(self) -> int: ...
    def tint(self, color: Colorc, out: Color) -> Color: ...
    def grayscale(self, out: Color) -> Color: ...
    def brightness(self, brightness: Union[int, float], out: Color) -> Color: ...
    def contrast(self, contrast: Union[int, float], out: Color) -> Color: ...
    def gamma(self, gamma: float, out: Color) -> Color: ...
    def invert(self, out: Color) -> Color: ...
    def brighter(self, percentage: float, out: Color) -> Color: ...
    def darker(self, percentage: float, out: Color) -> Color: ...
    def lerp(self, src: Colorc, t: float, out: Color) -> Color: ...
    def smooth_step(self, src: ColorLike, t: float, out: Color) -> Color: ...
    @overload
    def blend(self, src: Colorc, blend_mode: BlendMode, out: Color) -> Color: ...
    @overload
    def blend(self, src: Colorc, out: Color) -> Color: ...

class Color(Colorc, np.ndarray):
    @overload
    def __init__(self) -> Color: ...
    @overload
    def __init__(self, rgb: int, a: int = 255) -> Color: ...
    @overload
    def __init__(self, r: int, g: int, b: int, a: int = 255) -> Color: ...
    @overload
    def __init__(self, rgb: Vector3c, a: int = 255) -> Color: ...
    @overload
    def __init__(self, rgba: Colorc) -> Color: ...
    @overload
    def __init__(self, rgba: Vector4c) -> Color: ...
    @overload
    def __init__(self, rgba: Sequence[int]) -> Color: ...
    @overload
    def __init__(self, rgba: np.ndarray) -> Color: ...
    def __iadd__(self, other: ColorLike) -> Color: ...
    def __isub__(self, other: ColorLike) -> Color: ...
    def __imul__(self, other: ColorLike) -> Color: ...
    def __idiv__(self, other: ColorLike) -> Color: ...
    def __itruediv__(self, other: ColorLike) -> Color: ...
    def __ifloordiv__(self, other: ColorLike) -> Color: ...
    def __imod__(self, other: ColorLike) -> Color: ...
    def __idivmod__(self, other: ColorLike) -> Color: ...
    def __ipow__(self, other: ColorLike) -> Color: ...
    def __imatmul__(self, other: ColorLike) -> Color: ...
    @property
    def r(self) -> int: ...
    @r.setter
    def r(self) -> int: ...
    @property
    def g(self) -> int: ...
    @g.setter
    def g(self) -> int: ...
    @property
    def b(self) -> int: ...
    @b.setter
    def b(self) -> int: ...
    @property
    def a(self) -> int: ...
    @a.setter
    def a(self) -> int: ...
    @property
    def hsv(self) -> Vector3: ...
    @hsv.setter
    def hsv(self) -> Vector3: ...
    def tint(self, color: Colorc, out: Color = None) -> Color: ...
    def grayscale(self, out: Color = None) -> Color: ...
    def brightness(self, brightness: Union[int, float], out: Color = None) -> Color: ...
    def contrast(self, contrast: Union[int, float], out: Color = None) -> Color: ...
    def gamma(self, gamma: float, out: Color = None) -> Color: ...
    def invert(self, out: Color = None) -> Color: ...
    def brighter(self, percentage: float, out: Color = None) -> Color: ...
    def darker(self, percentage: float, out: Color = None) -> Color: ...
    def lerp(self, src: Colorc, t: float, out: Color = None) -> Color: ...
    def smooth_step(self, src: ColorLike, t: float, out: Color = None) -> Color: ...
    def blend(self, src: Colorc, blend_mode: BlendMode = None, out: Color = None) -> Color: ...

ColorLike = Union[Colorc, np.ndarray, int, Sequence[int]]
